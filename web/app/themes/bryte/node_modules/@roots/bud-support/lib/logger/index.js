import { __decorate } from "tslib";
import { cwd, env, stdout } from 'node:process';
import { bind } from '@roots/bud-support/decorators/bind';
import isUndefined from '@roots/bud-support/isUndefined';
import args from '@roots/bud-support/utilities/args';
import Signale from 'signale';
/**
 * Logger
 */
class Logger {
    options;
    /**
     * Enabled
     */
    enabled = false;
    /**
     * Logger instance
     */
    instance;
    /**
     * Verbose
     */
    verbose = false;
    /**
     * Class constructor
     */
    constructor(options = {}) {
        this.options = options;
        if (!args.silent) {
            if (args.log)
                this.enabled = true;
            if (this.options.logLevel &&
                [`info`, `log`].includes(this.options.logLevel))
                this.enabled = true;
        }
        if (args.verbose) {
            this.verbose = true;
            this.options.logLevel === `info`;
        }
        const secretEnv = Object.entries(env)
            .filter(([k, v]) => !isUndefined(v) && k.includes(`SECRET`))
            .map(([_, value]) => `${value}`);
        secretEnv.push(cwd());
        this.options.secrets = this.options.secrets
            ? [...this.options.secrets, ...secretEnv]
            : secretEnv;
        this.instance = new Signale.Signale(this.options);
        this.instance.config({ displayBadge: true, displayLabel: false });
    }
    await(...messages) {
        if (!this.enabled)
            return this;
        this.instance.await(...messages);
        return this;
    }
    debug(...messages) {
        if (!this.verbose)
            return this;
        this.instance.debug(...messages);
        return this;
    }
    error(...messages) {
        this.instance.error(...messages);
        return this;
    }
    info(...messages) {
        if (!this.verbose)
            return this;
        this.instance.info(...messages);
        return this;
    }
    log(...messages) {
        if (!this.enabled)
            return this;
        this.instance.log(...messages);
        return this;
    }
    scope(...scopes) {
        if (scopes.length === 0)
            return this;
        this.instance = this.instance.scope(...scopes);
        return this;
    }
    success(...messages) {
        if (!this.enabled)
            return this;
        this.instance.success(...messages);
        return this;
    }
    time(label = `default`) {
        if (!this.verbose)
            return this;
        this.instance.time(label);
        return this;
    }
    timeEnd(label = `default`) {
        if (!this.verbose)
            return this;
        this.instance.timeEnd(label);
        return this;
    }
    unscope() {
        this.instance.unscope();
        return this;
    }
    warn(...messages) {
        this.instance.warn(...messages);
        return this;
    }
}
__decorate([
    bind
], Logger.prototype, "await", null);
__decorate([
    bind
], Logger.prototype, "debug", null);
__decorate([
    bind
], Logger.prototype, "error", null);
__decorate([
    bind
], Logger.prototype, "info", null);
__decorate([
    bind
], Logger.prototype, "log", null);
__decorate([
    bind
], Logger.prototype, "scope", null);
__decorate([
    bind
], Logger.prototype, "success", null);
__decorate([
    bind
], Logger.prototype, "time", null);
__decorate([
    bind
], Logger.prototype, "timeEnd", null);
__decorate([
    bind
], Logger.prototype, "unscope", null);
__decorate([
    bind
], Logger.prototype, "warn", null);
let instance = new Logger({
    stream: [stdout],
});
export const initialize = (options) => {
    instance = new Logger(options);
    instance.log(`logger initialized`);
    return instance;
};
export { instance as default, Logger };
