interface Value<T> {
    identity: T;
    isBudValue: true;
}
declare class Value<T> {
    identity: T;
    static isBudValue: true;
    /**
     * Get {@link Value.identity}
     */
    static call<T, A extends any[]>(value: ((...args: A) => Promise<T>) | Value<T>, ...args: A): Promise<T>;
    /**
     * Get {@link Value.identity}
     */
    static get<T>(value: T | Value<T>): T;
    static isCallable<T>(value: T | Value<T>): value is T & CallableFunction;
    /**
     * Check {@link Value.identity} type
     */
    static isValue<T extends any>(value: T | Value<T>): value is Value<T>;
    /**
     * Make {@link Value} instance
     */
    static make<T>(value: T, ..._args: any[]): Value<T>;
    /**
     * Check {@link Value.identity} type
     */
    static typeOf<T>(value: T | Value<T>): string;
    /**
     * For type checking
     *
     * @remarks
     * Some functions like _.set() will mutate the class instance.
     * This property is used to check if the instance is a {@link Value}
     * and should work even after mutation.
     */
    isBudValue: true;
    /**
     * Class constructor
     *
     * @remarks
     * Singleton pattern. Use {@link Value.make} to create a {@link Value} instance.
     *
     * @param identity - Value
     * @private
     */
    constructor(identity: T);
    /**
     * Get value of {@link Value.identity}
     */
    get(): T;
}
export default Value;
