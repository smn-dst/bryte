import isObject from '@roots/bud-support/isObject';
const cwd = `${global.process.cwd()}`;
const clean = (message) => {
    return message
        ?.replace(new RegExp(cwd, `g`), `.`)
        .replace(/\s+/g, ` `)
        .replace(/file:\/\//g, ``);
};
/**
 * Error base class
 */
class BudError extends Error {
    /**
     * Is BudError
     */
    isBudError = true;
    /**
     * Normalize error
     */
    static normalize(source, options = {}) {
        if (source instanceof BudError) {
            Object.entries(options).map(([key, value]) => {
                source[key] = value;
            });
            return source;
        }
        if (source instanceof Error) {
            return new BudError(source.message, options);
        }
        if (typeof source === `string`) {
            return new BudError(source, options);
        }
        return new BudError(`An unknown error occured`, options);
    }
    /**
     * Class constructor
     */
    constructor(message, options = {}) {
        super(message);
        this.isBudError = true;
        this.name = this.constructor.name;
        this.message = (clean(message) ?? message)?.replace(/.*Error:/g, ``);
        if (options.details) {
            this.details = clean(options.details);
        }
        if (options.docs) {
            this.docs = options.docs;
        }
        if (options.file) {
            this.file = {
                ...options.file,
                path: clean(options.file.path),
            };
        }
        if (options.instance) {
            this.instance = options.instance;
        }
        if (options.issue) {
            this.issue = options.issue;
        }
        if (options.origin) {
            this.origin =
                isObject(options.origin) && `isBudError` in options.origin
                    ? options.origin
                    : BudError.normalize(options.origin);
        }
        if (options.thrownBy) {
            this.thrownBy =
                options.thrownBy instanceof URL
                    ? options.thrownBy.toString()
                    : options.thrownBy;
        }
        if (this.stack) {
            this.stack = this.stack
                .split(`\n`)
                .filter((line, i) => i > 0 && !line.includes(`bud-support`))
                .map(clean)
                .filter(Boolean)
                .join(`\n`);
        }
    }
}
class ModuleError extends BudError {
}
class ConfigError extends BudError {
}
class InputError extends BudError {
}
class CompilerError extends BudError {
}
class ServerError extends BudError {
}
class ExtensionError extends BudError {
}
export { BudError, CompilerError, ConfigError, ExtensionError, InputError, ModuleError, ServerError, };
