class Value {
    identity;
    static isBudValue = true;
    /**
     * Get {@link Value.identity}
     */
    static async call(value, ...args) {
        if (typeof value === `function`) {
            const fn = Value.get(value);
            return await fn(...args);
        }
        return Value.get(value);
    }
    /**
     * Get {@link Value.identity}
     */
    static get(value) {
        return Value.isValue(value) ? value.identity : value;
    }
    static isCallable(value) {
        return Value.typeOf(value) === `function`;
    }
    /**
     * Check {@link Value.identity} type
     */
    static isValue(value) {
        return (typeof value === `object` &&
            value !== null &&
            `identity` in value &&
            `isBudValue` in value &&
            value.isBudValue);
    }
    /**
     * Make {@link Value} instance
     */
    static make(value, ..._args) {
        return Value.isValue(value) ? value : new Value(value);
    }
    /**
     * Check {@link Value.identity} type
     */
    static typeOf(value) {
        return Value.isValue(value) ? typeof value.identity : typeof value;
    }
    /**
     * For type checking
     *
     * @remarks
     * Some functions like _.set() will mutate the class instance.
     * This property is used to check if the instance is a {@link Value}
     * and should work even after mutation.
     */
    isBudValue = true;
    /**
     * Class constructor
     *
     * @remarks
     * Singleton pattern. Use {@link Value.make} to create a {@link Value} instance.
     *
     * @param identity - Value
     * @private
     */
    constructor(identity) {
        this.identity = identity;
    }
    /**
     * Get value of {@link Value.identity}
     */
    get() {
        return this.identity;
    }
}
export default Value;
