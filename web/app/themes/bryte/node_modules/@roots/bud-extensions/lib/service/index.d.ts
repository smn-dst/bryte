import type { Bud, Modules } from '@roots/bud-framework';
import type { ApplyPlugin } from '@roots/bud-framework/extension';
import type { Extensions as BudExtensions, LifecycleMethods } from '@roots/bud-framework/services/extensions';
import { Extension } from '@roots/bud-framework/extension';
import { Service } from '@roots/bud-framework/service';
import Container from '@roots/container';
/**
 * Extensions Service
 */
declare class Extensions extends Service implements BudExtensions {
    /**
     * Resolved options
     */
    options: Container<{
        allowlist: Array<string>;
        denylist: Array<string>;
        discover: boolean;
    }>;
    /**
     * Registered extensions
     */
    repository: Modules;
    /**
     * Modules on which an import attempt was made and failed
     *
     * @remarks
     * This doesn't mean an error, per se. This should only
     * be used in the context of trying to import `optionalDependencies`
     * of a given extension module.
     *
     * @public
     */
    unresolvable: Set<string>;
    /**
     *
     * @param bud Class constructor
     */
    constructor(bud: () => Bud);
    /**
     * Add a {@link Extension} to the extensions repository
     */
    add<K extends `${keyof Modules & string}`>(extension: Array<K | (new (bud: Bud) => Partial<Extension>) | Partial<Extension>> | K | (new (bud: Bud) => Partial<Extension>) | Partial<Extension>): Promise<void>;
    /**
     * {@link BudExtensions.bootstrap}
     */
    configBefore?(bud: Bud): Promise<void>;
    /**
     * {@link BudExtensions.buildBefore}
     */
    buildAfter?(bud: Bud): Promise<void>;
    /**
     * {@link BudExtensions.buildBefore}
     */
    buildBefore?(bud: Bud): Promise<void>;
    /**
     * {@link BudExtensions.compilerDone}
     */
    compilerDone?(bud: any, stats: any): Promise<void>;
    /**
     * {@link BudExtensions.configAfter}
     */
    configAfter?(bud: Bud): Promise<void>;
    /**
     * Get extension
     */
    get<K extends `${keyof Modules & string}`>(key: K): Modules[K];
    /**
     * Has extension
     */
    has(key: string): key is `${keyof Modules & string}`;
    /**
     * Import an extension
     */
    import(signifier: string, required?: boolean | number): Promise<Extension>;
    /**
     * {@link BudExtensions.instantiate}
     */
    instantiate(source: {
        apply: (...args: any[]) => any;
    } | Extension | (new (...args: any[]) => Extension)): Promise<Extension>;
    /**
     * {@link BudExtensions.isAllowed}
     */
    isAllowed(signifier: string): boolean;
    /**
     * Returns an array of plugin instances which have been registered to the
     * container and are set to be used in the compilation
     *
     * @returns An array of plugin instances
     */
    make(): Promise<ApplyPlugin[]>;
    /**
     * Remove extension
     */
    remove<K extends `${keyof Modules & string}`>(key: K): this;
    /**
     * Run an extension lifecycle method
     *
     * @remarks
     * - `register`
     * - `boot`
     * - `buildBefore`
     * - `make`
     */
    run(extension: ApplyPlugin | Partial<Extension>, methodName: LifecycleMethods): Promise<this>;
    /**
     * Execute a extension lifecycle method on all registered extensions
     */
    runAll(methodName: LifecycleMethods): Promise<any>;
    /**
     * Run a lifecycle method for an extension's dependencies
     *
     * @remarks
     * Called from {@link Extension.run}. Ensures a method is run for an
     * extension's dependencies before it is run for the extension itself.
     */
    runDependencies<K extends `${keyof Modules & string}`>(extension: K | Modules[K], methodName: LifecycleMethods): Promise<void>;
    /**
     * Set extension
     */
    set(value: Extension): this;
}
export { Extensions as default };
