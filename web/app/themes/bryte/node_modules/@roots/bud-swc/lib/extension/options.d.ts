import type { Options } from '@swc/core';
import { Extension, type OptionCallback, type StrictPublicExtensionApi } from '@roots/bud-framework/extension';
import type { BudJSCPublicInterface, JSCOptions } from './jsc.js';
/**
 * Options related to SWC compiler
 *
 * @remarks
 * There are two additional properties: `typescript` and `ecmascript`.
 * These are used to override the base options for each language.
 * This is useful for using different options for
 * different file types but still using the same general config.
 */
type BudSWCOptions = {
    env?: Options[`env`];
    exclude?: Options[`exclude`];
    inlineSourcesContent?: Options[`inlineSourcesContent`];
    jsc?: Options[`jsc`];
    module?: Options[`module`];
    /**
     * - true to generate a sourcemap for the code and include it in the result object.
     * - "inline" to generate a sourcemap and append it as a data URL to the end of the code, but not include it in the result object.
     *
     * `swc-cli` overloads some of these to also affect how maps are written to disk:
     *
     * - true will write the map to a .map file on disk
     * - "inline" will write the file directly, so it will have a data: containing the map
     * - Note: These options are bit weird, so it may make the most sense to just use true
     *  and handle the rest in your own code, depending on your use case.
     */
    sourceMaps?: Options[`sourceMaps`];
    /**
     * Note: The type is string because it follows rust's regex syntax.
     */
    test?: Options[`test`];
};
type BudSWCPublicInterface = StrictPublicExtensionApi<BudSWCApi, BudSWCOptions> & {
    baseUrl: BudSWCOptions[`jsc`][`baseUrl`];
    ecmascript: BudJSCPublicInterface;
    experimental: BudSWCOptions[`jsc`][`experimental`];
    externalHelpers: BudSWCOptions[`jsc`][`externalHelpers`];
    getBaseUrl(): BudSWCOptions[`jsc`][`baseUrl`];
    getExperimental(): BudSWCOptions[`jsc`][`experimental`];
    getExternalHelpers(): BudSWCOptions[`jsc`][`externalHelpers`];
    getKeepClassNames(): BudSWCOptions[`jsc`][`keepClassNames`];
    getLoose(): BudSWCOptions[`jsc`][`loose`];
    getMinify(): BudSWCOptions[`jsc`][`minify`];
    getParser(): BudSWCOptions[`jsc`][`parser`];
    getPlugins(plugins: OptionCallback<JSCOptions[`experimental`], `plugins`>): BudSWCPublicInterface;
    getPreserveAllComments(): BudSWCOptions[`jsc`][`preserveAllComments`];
    getTarget(): BudSWCOptions[`jsc`][`target`];
    getTransform(): BudSWCOptions[`jsc`][`transform`];
    keepClassNames: BudSWCOptions[`jsc`][`keepClassNames`];
    loose: BudSWCOptions[`jsc`][`loose`];
    minify: BudSWCOptions[`jsc`][`minify`];
    parser: BudSWCOptions[`jsc`][`parser`];
    plugins: BudSWCOptions[`jsc`][`experimental`][`plugins`];
    preserveAllComments: BudSWCOptions[`jsc`][`preserveAllComments`];
    setBaseUrl(baseUrl: OptionCallback<JSCOptions, `baseUrl`>): BudSWCPublicInterface;
    setExperimental(experimental: OptionCallback<JSCOptions, `experimental`>): BudSWCPublicInterface;
    setExperimentalPlugins(plugins: OptionCallback<JSCOptions[`experimental`], `plugins`>): BudSWCPublicInterface;
    setExternalHelpers(externalHelpers: OptionCallback<JSCOptions, `externalHelpers`>): BudSWCPublicInterface;
    setKeepClassNames(keepClassNames: OptionCallback<JSCOptions, `keepClassNames`>): BudSWCPublicInterface;
    setLoose(loose: OptionCallback<JSCOptions, `loose`>): BudSWCPublicInterface;
    setMinify(minify: OptionCallback<JSCOptions, `minify`>): BudSWCPublicInterface;
    setParser(parser: OptionCallback<JSCOptions, `parser`>): BudSWCPublicInterface;
    setPlugins(plugins: OptionCallback<JSCOptions[`experimental`], `plugins`>): BudSWCPublicInterface;
    setPreserveAllComments(preserveAllComments: OptionCallback<JSCOptions, `preserveAllComments`>): BudSWCPublicInterface;
    setTarget(target: OptionCallback<JSCOptions, `target`>): BudSWCPublicInterface;
    setTransform(transform: OptionCallback<JSCOptions, `transform`>): BudSWCPublicInterface;
    target: BudSWCOptions[`jsc`][`target`];
    transform: BudSWCOptions[`jsc`][`transform`];
    typescript: BudJSCPublicInterface;
};
declare class BudSWCApi extends Extension<BudSWCOptions> {
    env: BudSWCPublicInterface[`env`];
    exclude: BudSWCPublicInterface[`exclude`];
    getEnv: BudSWCPublicInterface[`getEnv`];
    getExclude: BudSWCPublicInterface[`getExclude`];
    getInlineSourcesContent: BudSWCPublicInterface[`getInlineSourcesContent`];
    getJsc: BudSWCPublicInterface['getJsc'];
    getModule: BudSWCPublicInterface[`getModule`];
    getSourceMaps: BudSWCPublicInterface[`getSourceMaps`];
    getTest: BudSWCPublicInterface[`getTest`];
    inlineSourcesContent: BudSWCPublicInterface[`inlineSourcesContent`];
    jsc: BudSWCPublicInterface['jsc'];
    module: BudSWCPublicInterface[`module`];
    setEnv: BudSWCPublicInterface[`setEnv`];
    setExclude: BudSWCPublicInterface[`setExclude`];
    setInlineSourcesContent: BudSWCPublicInterface[`setInlineSourcesContent`];
    setJsc: BudSWCPublicInterface['setJsc'];
    setModule: BudSWCPublicInterface[`setModule`];
    setSourceMaps: BudSWCPublicInterface[`setSourceMaps`];
    setTest: BudSWCPublicInterface[`setTest`];
    sourceMaps: BudSWCPublicInterface[`sourceMaps`];
    test: BudSWCPublicInterface[`test`];
    get baseUrl(): string;
    get experimental(): {
        optimizeHygiene?: boolean;
        keepImportAttributes?: boolean;
        emitAssertForImportAttributes?: boolean;
        cacheRoot?: string;
        plugins?: [string, Record<string, any>][];
        disableBuiltinTransformsForInternalTesting?: boolean;
    };
    get externalHelpers(): boolean;
    getBaseUrl(): string;
    getExperimental(): {
        optimizeHygiene?: boolean;
        keepImportAttributes?: boolean;
        emitAssertForImportAttributes?: boolean;
        cacheRoot?: string;
        plugins?: [string, Record<string, any>][];
        disableBuiltinTransformsForInternalTesting?: boolean;
    };
    getExternalHelpers(): boolean;
    getKeepClassNames(): boolean;
    getLoose(): boolean;
    getMinify(): import("@swc/types").JsMinifyOptions;
    getParser(): import("@swc/types").ParserConfig;
    getPreserveAllComments(): boolean;
    getTarget(): import("@swc/types").JscTarget;
    getTransform(): import("@swc/types").TransformConfig;
    get keepClassNames(): boolean;
    get loose(): boolean;
    get minify(): import("@swc/types").JsMinifyOptions;
    get parser(): import("@swc/types").ParserConfig;
    get preserveAllComments(): boolean;
    setBaseUrl(baseUrl: OptionCallback<JSCOptions, `baseUrl`>): this;
    setExperimental(experimental: OptionCallback<JSCOptions, `experimental`>): this;
    /**
     * Set SWC plugins
     */
    setExperimentalPlugins(input: OptionCallback<JSCOptions[`experimental`], `plugins`>): this;
    setExternalHelpers(externalHelpers: OptionCallback<JSCOptions, `externalHelpers`>): this;
    setKeepClassNames(keepClassNames: OptionCallback<JSCOptions, `keepClassNames`>): this;
    setLoose(loose: OptionCallback<JSCOptions, `loose`>): this;
    setMinify(minify: OptionCallback<JSCOptions, `minify`>): this;
    setParser(parser: OptionCallback<JSCOptions, `parser`>): this;
    setPlugins(input: OptionCallback<JSCOptions[`experimental`], `plugins`>): this;
    setPreserveAllComments(preserveAllComments: OptionCallback<JSCOptions, `preserveAllComments`>): this;
    setTarget(target: OptionCallback<JSCOptions, `target`>): this;
    setTransform(transform: OptionCallback<JSCOptions, `transform`>): this;
    get target(): import("@swc/types").JscTarget;
    get transform(): import("@swc/types").TransformConfig;
}
export { BudSWCApi, type BudSWCPublicInterface, type Options };
