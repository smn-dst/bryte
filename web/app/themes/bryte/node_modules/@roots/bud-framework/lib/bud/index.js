import { __decorate } from "tslib";
import methods from '@roots/bud-framework/methods';
import { bind } from '@roots/bud-support/decorators/bind';
import { BudError, InputError } from '@roots/bud-support/errors';
import isFunction from '@roots/bud-support/isFunction';
import isString from '@roots/bud-support/isString';
import isUndefined from '@roots/bud-support/isUndefined';
import logger from '@roots/bud-support/logger';
import { bootstrap } from '../bootstrap.js';
/**
 * Bud core class
 */
export class Bud {
    /**
     * Promised tasks
     */
    promised = [];
    /**
     * True when child compilers
     * @readonly
     */
    get hasChildren() {
        return this.children && Object.entries(this.children).length > 0;
    }
    /**
     * True when current instance is a child instance
     * @readonly
     */
    get isChild() {
        return this.root?.context?.label !== this.context?.label;
    }
    /**
     * True when {@link Bud.mode} is `development`
     * @readonly
     */
    get isDevelopment() {
        return this.mode === `development`;
    }
    /**
     * True when {@link Bud.mode} is `production`
     * @readonly
     */
    get isProduction() {
        return this.mode === `production`;
    }
    /**
     * True when current instance is the parent instance
     * @readonly
     */
    get isRoot() {
        return this.root?.context?.label === this.context?.label;
    }
    /**
     * Label
     * @readonly
     */
    get label() {
        return this.context?.label ?? `bud`;
    }
    /**
     * Compilation mode
     *
     * @remarks
     * Either `production` or `development`.
     *
     * @readonly
     * @defaultValue `production`
     */
    get mode() {
        return this.context?.mode ?? `production`;
    }
    /**
     * Constructor
     */
    constructor(context) {
        if (context)
            this.context = { ...context };
        this.set(`implementation`, this.constructor);
        Object.entries(methods).map(([k, v]) => this.set(k, v.bind(this)));
    }
    /**
     * Boot application services
     */
    async boot() {
        await this.executeServiceCallbacks(`boot`).catch(this.catch);
    }
    /**
     * Bootstrap the application
     */
    async bootstrap() {
        await this.executeServiceCallbacks(`bootstrap`).catch(this.catch);
    }
    /**
     * Error handler
     */
    catch(error) {
        const normalizedError = BudError.normalize(error);
        if (!normalizedError.instance && this?.isChild)
            normalizedError.instance = this.label;
        throw normalizedError;
    }
    /**
     * Execute service callbacks for a given stage
     * @internal
     */
    async executeServiceCallbacks(stage) {
        await this.resolvePromises().catch(this.catch);
        await this.hooks.fire(stage, this);
    }
    /**
     * Bud initialize
     */
    async initialize(context) {
        if (context)
            this.context = { ...(this.context ?? {}), ...context };
        await bootstrap(this).catch(this.catch);
        await this.bootstrap().catch(this.catch);
        await this.register().catch(this.catch);
        await this.boot().catch(this.catch);
        await this.executeServiceCallbacks(`config.before`).catch(this.catch);
        return this;
    }
    /**
     * Creates a child and returns the parent instance
     */
    async make(request, setupFn) {
        if (!this.isRoot) {
            return this.catch(InputError.normalize(`bud.make: must be called from the root context`));
        }
        const context = isString(request)
            ? { ...this.context, label: request, root: this }
            : { ...this.context, ...request, root: this };
        if (isUndefined(context.label)) {
            return this.catch(InputError.normalize(`bud.make: context.label must be a string`));
        }
        if (!isUndefined(this.context.filter) &&
            !this.context.filter.includes(context.label)) {
            logger
                .scope(`make`)
                .log(`skipping child instance based on --filter flag:`, context.label);
            return this;
        }
        if (!this.children)
            this.children = {};
        if (this.children[context.label]) {
            return this.catch(InputError.normalize(`bud.make: child instance ${context.label} already exists`));
        }
        logger.scope(`make`).log(`instantiating ${context.label}`);
        this.children[context.label] =
            await new this.implementation().initialize({
                ...context,
            });
        if (setupFn)
            await setupFn(this.children[context.label]);
        await this.children[context.label].resolvePromises().catch(this.catch);
        if (typeof request !== `string` && request.dependsOn) {
            this.get(context.label)?.hooks.on(`build.dependencies`, request.dependsOn);
        }
        return this;
    }
    /**
     * Await all promised tasks
     */
    promise(promise) {
        this.promised.push(promise);
        return this;
    }
    async resolvePromises() {
        if (this.promised.length === 0)
            return;
        const promises = this.promised;
        this.promised = [];
        await promises.reduce(async (promised, promise) => {
            await promised;
            await promise(this);
        }, Promise.resolve());
    }
    /**
     * Register application services
     */
    async register() {
        await this.executeServiceCallbacks(`register`).catch(this.catch);
    }
    /**
     * Parent {@link Bud} instance
     * @readonly
     */
    get root() {
        return this.context?.root ?? this;
    }
    /**
     * Set a value on the current instance
     * @param key - key
     * @param value - value
     * @param bind - bind value to current instance (default: true, if bindable)
     */
    set(key, input, bind = true) {
        const toBind = bind && isFunction(input) && `bind` in input;
        const value = toBind ? input.bind(this) : input;
        Object.defineProperty(this, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true,
        });
        return this;
    }
    /**
     * Log message
     * @deprecated Import logger instance from `@roots/bud-support/logger`
     */
    log(...messages) {
        logger.scope(this.label).log(...messages);
        return this;
    }
    /**
     * Log success
     * @deprecated Import logger instance from `@roots/bud-support/logger`
     */
    success(...messages) {
        logger.scope(this.label).log(...messages);
        return this;
    }
    /**
     * Log warning
     * @deprecated Import logger instance from `@roots/bud-support/logger`
     */
    warn(...messages) {
        logger.scope(this.label).warn(...messages);
        return this;
    }
    /**
     * Log info
     * @deprecated Import logger instance from `@roots/bud-support/logger`
     */
    info(...messages) {
        logger.scope(this.label).info(...messages);
        return this;
    }
    /**
     * Log error
     * @deprecated Import logger instance from `@roots/bud-support/logger`
     */
    error(...messages) {
        logger.scope(this.label).error(...messages);
        return this;
    }
}
__decorate([
    bind
], Bud.prototype, "boot", null);
__decorate([
    bind
], Bud.prototype, "bootstrap", null);
__decorate([
    bind
], Bud.prototype, "catch", null);
__decorate([
    bind
], Bud.prototype, "executeServiceCallbacks", null);
__decorate([
    bind
], Bud.prototype, "initialize", null);
__decorate([
    bind
], Bud.prototype, "make", null);
__decorate([
    bind
], Bud.prototype, "promise", null);
__decorate([
    bind
], Bud.prototype, "resolvePromises", null);
__decorate([
    bind
], Bud.prototype, "register", null);
__decorate([
    bind
], Bud.prototype, "set", null);
__decorate([
    bind
], Bud.prototype, "log", null);
__decorate([
    bind
], Bud.prototype, "success", null);
__decorate([
    bind
], Bud.prototype, "warn", null);
__decorate([
    bind
], Bud.prototype, "info", null);
__decorate([
    bind
], Bud.prototype, "error", null);
