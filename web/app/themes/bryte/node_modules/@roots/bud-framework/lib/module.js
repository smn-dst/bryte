import { __decorate } from "tslib";
import { join, normalize, relative } from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';
import { bind } from '@roots/bud-support/decorators/bind';
import { BudError, ModuleError } from '@roots/bud-support/errors';
import { resolve } from '@roots/bud-support/import-meta-resolve';
import isEqual from '@roots/bud-support/isEqual';
import logger from '@roots/bud-support/logger';
import noop from '@roots/bud-support/noop';
import {} from './index.js';
import { Service } from './service.js';
/**
 * Module resolver
 */
export class Module extends Service {
    /**
     * Cached resolutions data
     */
    cache = {
        resolutions: {},
        sha1: null,
        version: null,
    };
    /**
     * Imported modules
     */
    modules = {};
    /**
     * Resolved module paths
     */
    resolutions = {};
    /**
     * Cache enabled
     */
    get cacheEnabled() {
        return this.args.force !== true;
    }
    /**
     * Cache location
     */
    get cachePath() {
        return join(this.paths.storage, `bud.resolutions.yml`);
    }
    /**
     * Constructor
     */
    constructor(options) {
        super(options.app);
        this.args = options.args;
        this.paths = options.paths;
    }
    /**
     * {@link Service.bootstrap}
     */
    async bootstrap(bud) {
        if (!this.cacheEnabled) {
            this.logger.scope(`module`).log(`--force used. resetting cache.`);
            return await this.resetCache();
        }
        if (await bud.fs.exists(this.cachePath)) {
            this.logger.scope(`module`).log(`cache is enabled and exists`);
            this.cache = await bud.fs.read(this.cachePath).catch(noop);
        }
        if (!this.cache?.resolutions ||
            this.cache?.sha1 !== bud.context.files[`package`]?.sha1) {
            this.logger
                .scope(`module`)
                .log(`cache is enabled but package.json has changed. resetiing cache.`);
            return await this.resetCache();
        }
        this.resolutions = { ...this.cache.resolutions };
    }
    /**
     * At end of process write resolutions to cache
     */
    async after(bud) {
        if (isEqual(this.cache.resolutions, this.resolutions)) {
            this.logger
                .scope(`module`)
                .log(`resolutions unchanged. skipping write.`)
                .info(`resolutions:`, this.resolutions)
                .info(`cache:`, this.cache);
            return bud;
        }
        logger
            .scope(`module`)
            .log(`writing resolutions`)
            .info(this.resolutions);
        await bud.fs.write(this.cachePath, {
            resolutions: this.resolutions,
            sha1: bud.context.files[`package`]?.sha1,
            version: bud.context.bud.version,
        });
        return bud;
    }
    /**
     * Get `package.json` absolute path from a module signifier
     */
    async getDirectory(signifier, context) {
        this.logger.scope(`module`).info(`getDirectory`, signifier, context);
        return await this.resolve(signifier, context)
            .then(path => relative(this.app.context.basedir, path))
            .then(path => path.split(signifier).shift())
            .then(path => this.app.path(path, signifier))
            .catch(this.catch);
    }
    /**
     * Get `package.json` absolute path from a module signifier
     */
    async getManifestPath(signifier) {
        this.logger.scope(`module`).info(`getManifestPath`, signifier);
        return await this.getDirectory(signifier)
            .then(dir => this.app.path(dir, `package.json`))
            .catch(this.catch);
    }
    /**
     * Import a module from its signifier
     */
    async import(signifier, context, options = {
        bustCache: false,
        raw: false,
    }) {
        if (options.bustCache) {
            signifier = `${signifier}?v=${Date.now()}`;
        }
        if (this.hasModule(signifier)) {
            const code = this.getModule(signifier);
            logger.scope(`module`).log(`[cache hit]`, `module:`, signifier);
            return options.raw ? code : code?.default ?? code;
        }
        if (!this.hasResolution(signifier)) {
            await this.resolve(signifier, context).catch(this.catch);
        }
        const code = await import(this.getResolution(signifier)).catch(error => {
            logger
                .scope(`module`)
                .log(`Could not import module:`, signifier, `Removing from cached module registry.`, error);
            this.removeResolution(signifier);
        });
        if (!code) {
            throw BudError.normalize(`Could not import ${signifier}`);
        }
        this.setModule(signifier, code);
        logger.scope(`module`).log(`imported module:`, signifier);
        return options.raw ? code : code?.default ?? code;
    }
    /**
     * Make context URL
     */
    makeContextURL(context) {
        if (context instanceof URL)
            return context;
        if (context)
            return pathToFileURL(context);
        return pathToFileURL(join(this.app.context.basedir, `package.json`));
    }
    /**
     * Read `package.json` manifest from a module signifier
     */
    async readManifest(signifier) {
        return await this.getManifestPath(signifier).then(async (path) => {
            const value = await this.app.fs.read(path);
            logger.scope(`module`).info(signifier, `manifest`, value);
            return value;
        });
    }
    /**
     * Reset cache
     */
    async resetCache() {
        this.logger.scope(`module`).log(`clearing runtime module cache`);
        this.cache = {
            resolutions: {},
            sha1: this.app.context.files[`package`]?.sha1,
            version: this.app.context.bud?.version,
        };
        this.resolutions = { ...this.cache.resolutions };
        if (await this.app.fs.exists(this.cachePath)) {
            this.logger
                .scope(`module`)
                .log(`removing cache file`, this.cachePath);
            await this.app.fs.remove(this.cachePath);
        }
    }
    /**
     * Resolve a module path from its signifier
     */
    async resolve(signifier, context) {
        if (this.hasResolution(signifier)) {
            logger
                .scope(`module`)
                .info(`[cache hit]`, `path:`, signifier, `=>`, this.getResolution(signifier));
            return this.resolutions[signifier];
        }
        await resolve(signifier, this.makeContextURL())
            .then(path => {
            this.setResolution(signifier, normalize(fileURLToPath(path)));
            logger
                .scope(`module`)
                .log(`[cache miss]`, `path:`, signifier, `=>`, this.getResolution(signifier));
        })
            .catch(noop);
        if (this.hasResolution(signifier))
            return this.getResolution(signifier);
        await resolve(signifier, this.makeContextURL(context))
            .then(path => {
            this.setResolution(signifier, normalize(fileURLToPath(path)));
            logger
                .scope(`module`)
                .log(`[cache miss]`, `path:`, signifier, `=>`, this.getResolution(signifier));
        })
            .catch(noop);
        if (this.hasResolution(signifier))
            return this.getResolution(signifier);
        throw new ModuleError(`Could not resolve ${signifier}`);
    }
    /**
     * Get a previously imported module
     */
    getModule(signifier) {
        return this.modules[signifier];
    }
    /**
     * Check if a module has been imported
     */
    hasModule(signifier) {
        return signifier in this.modules;
    }
    /**
     * Remove a module
     */
    removeModule(signifier) {
        return delete this.modules[signifier];
    }
    /**
     * Set a module
     */
    setModule(signifier, module) {
        this.modules[signifier] = module;
    }
    /**
     * Get a module resolution
     */
    getResolution(signifier) {
        return this.resolutions[signifier];
    }
    /**
     * Check if a module has been resolved
     */
    hasResolution(signifier) {
        return signifier in this.resolutions;
    }
    removeResolution(signifier) {
        return delete this.resolutions[signifier];
    }
    /**
     * Resolve a module from a particular URL
     */
    setResolution(signifier, url) {
        this.resolutions[signifier] = url;
    }
}
__decorate([
    bind
], Module.prototype, "bootstrap", null);
__decorate([
    bind
], Module.prototype, "after", null);
__decorate([
    bind
], Module.prototype, "getDirectory", null);
__decorate([
    bind
], Module.prototype, "getManifestPath", null);
__decorate([
    bind
], Module.prototype, "import", null);
__decorate([
    bind
], Module.prototype, "makeContextURL", null);
__decorate([
    bind
], Module.prototype, "readManifest", null);
__decorate([
    bind
], Module.prototype, "resetCache", null);
__decorate([
    bind
], Module.prototype, "resolve", null);
__decorate([
    bind
], Module.prototype, "getModule", null);
__decorate([
    bind
], Module.prototype, "hasModule", null);
__decorate([
    bind
], Module.prototype, "removeModule", null);
__decorate([
    bind
], Module.prototype, "setModule", null);
__decorate([
    bind
], Module.prototype, "getResolution", null);
__decorate([
    bind
], Module.prototype, "hasResolution", null);
__decorate([
    bind
], Module.prototype, "removeResolution", null);
__decorate([
    bind
], Module.prototype, "setResolution", null);
