import type { Modules } from '@roots/bud-framework';
import type { Compiler } from '@roots/bud-framework/config';
import type { ApplyPluginConstructor } from '@roots/bud-framework/extension/decorators/plugin';
import { Bud } from '@roots/bud-framework';
import logger from '@roots/bud-support/logger';
import DynamicOption from '@roots/bud-support/value';
export type Options<T = Record<string, any>> = {
    [K in keyof T as `${K & string}`]?: T[K];
};
export type InternalOptionsValues<T extends Options> = {
    [K in keyof T as `${K & string}`]: DynamicOption<(app: Bud) => T[K]> | T[K];
};
export type OptionCallback<T extends Options, K extends `${keyof Options & string}`> = ((value: T[K]) => T[K]) | T[K];
export type OptionCallbackValue<T extends Options, K extends `${keyof Options & string}`> = ((value: T[K]) => T[K]) | InternalOptionsValues<T>[K];
export type OptionSetter<Extension, Options, Property extends `${keyof Options & string}`> = (value: OptionCallbackValue<Options, Property>) => Extension;
export type OptionGetter<Options extends Record<string, any>, Property extends `${keyof Options & string}`> = () => Options[Property];
export type OptionAccessor<Options extends Record<string, any>, Property extends `${keyof Options & string}`> = Options[Property];
export type Option<Extension, Options extends Record<string, any>, Property extends `${keyof Options & string}`> = {
    get: OptionGetter<Options, Property>;
    set: OptionSetter<Extension, Options, Property>;
    value: OptionAccessor<Options, Property>;
};
export interface Meta {
    boot: boolean;
    buildAfter: boolean;
    buildBefore: boolean;
    compilerDone: boolean;
    configAfter: boolean;
    register: boolean;
}
/**
 * Webpack plugin.
 */
export interface ApplyPlugin {
    /**
     * @see {@link https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture}
     */
    apply(...args: any[]): unknown;
}
export interface Constructor {
    new (...args: any[]): Extension;
}
export type WithOptions<Context, Options> = {
    [Prop in keyof Options as `get${Capitalize<Prop & string>}`]: () => Options[Prop];
} & {
    [Prop in keyof Options as `set${Capitalize<Prop & string>}`]: (value: OptionCallbackValue<Options, `${Prop & string}`>) => Context;
} & {
    [K in keyof Options as `${K & string}`]: Options[K];
};
/**
 * Public extension interface
 */
export type PublicExtensionApi<ExtensionImplementation extends Extension = Extension> = {
    /**
     * ## Extension.app
     *
     * {@link Bud} instance
     */
    app: ExtensionImplementation[`app`];
    /**
     * ## Extension.done
     *
     * {@link ExtensionImplementation.done}
     *
     * @remarks
     * Returns the {@link Bud} instance from the extension. This is useful
     * for chaining method calls.
     *
     * @example
     * ```js
     * app
     *  .extensions
     *    .get('@roots/bud-postcss')
     *    .set('plugins', [])
     *    .done()
     *
     *  .entry('app', 'src/index.js')
     * ```
     */
    done: ExtensionImplementation[`done`];
    /**
     * ## Extension.enable
     *
     * Enable or disable extension
     *
     * @remarks
     * The following methods are skipped if `enabled` is false:
     * - {@link Extension.buildBefore}
     * - {@link Extension.buildAfter}
     * - {@link Extension.make}
     *
     * @example
     * Enable extension:
     * ```js
     * app.extensions.get('@roots/bud-postcss').enable()
     * ```
     *
     * @example
     * Disable extension:
     * ```js
     * app.extensions.get('@roots/bud-postcss').enable(false)
     * ```
     *
     * @example
     * Functional callback:
     * ```js
     * app.when(app.isProduction, app.extensions.get('@roots/bud-postcss').enable)
     * ```
     */
    enable: ExtensionImplementation['enable'];
    /**
     * ## Extension.enabled
     *
     * Property indicating if the extension is enabled
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').enabled
     * ```
     */
    enabled: ExtensionImplementation['enabled'];
    /**
     * ## Extension.get
     *
     * Get the value of an option record by key
     *
     * @remarks
     * Alias for {@link Extension.getOption}
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').get('plugins')
     * ```
     */
    get: ExtensionImplementation[`getOption`];
    /**
     * ## Extension.getOption
     *
     * Get the value of an option record by key
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').getOption('plugins')
     * ```
     */
    getOption: ExtensionImplementation[`getOption`];
    /**
     * ## Extension.getOptions
     *
     * Get all options records
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').getOptions()
     * ```
     */
    getOptions: ExtensionImplementation[`getOptions`];
    /**
     * ## Extension.logger
     *
     * @remarks
     * This logger is scoped to the extension
     */
    logger: ExtensionImplementation[`logger`];
    /**
     * ## Extension.options
     *
     * Options accessor
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').options
     * ```
     */
    options: ExtensionImplementation['options'];
    /**
     * ## Extension.set
     *
     * Set an option value
     *
     * @remarks
     * Alias for {@link Extension.setOption}
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').set('plugins', [])
     * ```
     */
    set: ExtensionImplementation[`set`];
    /**
     * ## Extension.setOption
     *
     * Set an option value
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').setOption('plugins', [])
     * ```
     */
    setOption: ExtensionImplementation[`setOption`];
    /**
     * ## Extension.setOptions
     *
     * Overwrite existing options
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').setOptions({plugins: []})
     * ```
     */
    setOptions: ExtensionImplementation[`setOptions`];
};
export type StrictPublicExtensionApi<Context, OptionsRecords extends Options> = {
    /**
     * ## Extension.app
     *
     * {@link Bud} instance
     */
    app: PublicExtensionApi[`app`];
    /**
     * ## Extension.done
     *
     * Returns the {@link Bud} instance from the extension.
     *
     * @remarks
     * This is useful for chaining method calls.
     *
     * @example
     * ```js
     * app
     *  .extensions
     *    .get('@roots/bud-postcss')
     *    .set('plugins', [])
     *    .done()
     *
     *  .entry('app', 'src/index.js')
     * ```
     */
    done: PublicExtensionApi[`done`];
    /**
     * ## Extension.enable
     *
     * Enable or disable extension
     *
     * @remarks
     * The following methods are skipped if `enabled` is false:
     * - {@link Extension.buildBefore}
     * - {@link Extension.buildAfter}
     * - {@link Extension.make}
     *
     * @example
     * Enable extension:
     * ```js
     * app.extensions.get('@roots/bud-postcss').enable()
     * ```
     *
     * @example
     * Disable extension:
     * ```js
     * app.extensions.get('@roots/bud-postcss').enable(false)
     * ```
     *
     * @example
     * Functional callback:
     * ```js
     * app.when(app.isProduction, app.extensions.get('@roots/bud-postcss').enable)
     * ```
     */
    enable: PublicExtensionApi[`enable`];
    /**
     * ## Extension.enabled
     *
     * Property indicating if the extension is enabled
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').enabled
     * ```
     */
    enabled: PublicExtensionApi[`enabled`];
    /**
     * ## Extension.get
     *
     * Get the value of an option record by key
     *
     * @remarks
     * Alias for {@link Extension.getOption}
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').get('plugins')
     * ```
     */
    get: <K extends `${keyof OptionsRecords & string}`>(key: K) => OptionsRecords[K];
    /**
     * ## Extension.getOptions
     *
     * Get all options records
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').getOptions()
     * ```
     */
    getOptions: () => OptionsRecords;
    /**
     * ## Extension.logger
     *
     * @remarks
     * This logger is scoped to the extension
     */
    logger: typeof logger;
    /**
     * ## Extension.options
     *
     * Options records accessor
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').options
     * ```
     */
    options: OptionsRecords;
    /**
     * ## Extension.set
     *
     * Set an option value
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').set('plugins', [])
     * ```
     */
    set: <K extends `${keyof OptionsRecords & string}`>(key: K, value: ((value: OptionsRecords[K]) => OptionsRecords[K]) | OptionsRecords[K]) => Context;
    /**
     * ## Extension.setOptions
     *
     * Overwrite existing options
     *
     * @example
     * ```js
     * app.extensions.get('@roots/bud-postcss').setOptions({plugins: []})
     * ```
     */
    setOptions: (O: Partial<InternalOptionsValues<OptionsRecords>>) => Context;
} & WithOptions<Context, OptionsRecords>;
export type ExtensionLiteral = Partial<Extension>;
export type * as Logger from '@roots/bud-support/logger';
/**
 * Bud extension
 */
export declare class Extension<ExtensionOptions extends Options = Options, Plugin extends {
    apply: (...args: any[]) => unknown;
} = ApplyPlugin> {
    /**
     * {@link Bud} instance get fn
     */
    private _app;
    /**
     * Extension options
     */
    _options: Partial<InternalOptionsValues<ExtensionOptions>>;
    /**
     * Depends on
     */
    dependsOn?: Set<keyof Modules & string>;
    /**
     * Depends on (optional)
     */
    dependsOnOptional?: Set<`${keyof Modules & string}`>;
    /**
     * The module name
     */
    label?: `${keyof Modules & string}`;
    /**
     * Extension options
     *
     * @readonly
     */
    options: ExtensionOptions;
    /**
     * {@link ApplyPlugin.apply} callback
     */
    apply?(compiler: Compiler): unknown | void;
    /**
     * `boot` callback
     */
    boot?(app: Bud): Promise<unknown | void>;
    /**
     * `buildAfter` callback
     */
    buildAfter?(app: Bud): Promise<unknown | void>;
    /**
     * `buildBefore` callback
     */
    buildBefore?(app: Bud): Promise<unknown | void>;
    /**
     * `configAfter` callback
     */
    configAfter?(app: Bud): Promise<unknown | void>;
    /**
     * Plugin constructor
     */
    plugin?: ApplyPluginConstructor;
    /**
     * Function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * If set this takes precedence over {@link Extension.enabled}.
     */
    when?(bud: Bud, options?: ExtensionOptions): boolean;
    get app(): Bud;
    enabled: boolean;
    /**
     * ## Extension.meta
     *
     * @remarks
     * Tracks which extension methods have been executed to prevent
     * duplicate execution in race conditions, etc.
     */
    meta: Meta;
    /**
     * Class constructor
     */
    constructor(app: Bud);
    /**
     * Error handler
     */
    catch(error: Error | string): never;
    /**
     * Disable extension
     * @deprecated pass `false` to {@link Extension.enable}
     */
    disable(): void;
    /**
     * Return to bud instance from extension
     */
    done(): Bud;
    /**
     * Enable extension
     */
    enable(enabled?: boolean | Bud): this;
    /**
     * Get option
     */
    getOption<K extends string>(key: K): ExtensionOptions[K];
    /**
     * Get an option value
     */
    get: <K extends string>(key: K) => ExtensionOptions[K];
    /**
     * Get options
     */
    getOptions(): ExtensionOptions;
    /**
     * Import ESM module
     */
    import<T = any>(signifier: string, context: string, options?: {
        bustCache?: boolean;
        raw?: boolean;
    }): Promise<T | undefined>;
    /**
     * Is extension enabled?
     */
    isEnabled(): boolean;
    /**
     * Logger instance
     */
    get logger(): any;
    /**
     * `make` callback
     */
    make?(app: Bud, options?: ExtensionOptions): Promise<Plugin>;
    /**
     * {@link Extension.register}
     */
    register?(app: Bud): Promise<any>;
    /**
     * Resolve module using `import.meta.resolve` api
     */
    resolve(signifier: string, context: string): Promise<string>;
    /**
     * Set option
     */
    setOption<K extends string>(key: K, valueOrCallback: OptionCallbackValue<ExtensionOptions, K>): this;
    /**
     * Set option
     */
    set: <K extends string>(key: K, valueOrCallback: OptionCallbackValue<ExtensionOptions, K>) => this;
    /**
     * Set options
     */
    setOptions(value: Partial<InternalOptionsValues<ExtensionOptions>>): this;
    execute(key: `${keyof Meta & string}` | `make`): Promise<false | import("@roots/bud-framework/extension/decorators/plugin").ApplyPlugin | Plugin | this>;
}
export { DynamicOption };
