import { __decorate } from "tslib";
import { Bud } from '@roots/bud-framework';
import { bind } from '@roots/bud-support/decorators/bind';
import { BudError, ExtensionError } from '@roots/bud-support/errors';
import get from '@roots/bud-support/get';
import isFunction from '@roots/bud-support/isFunction';
import isObject from '@roots/bud-support/isObject';
import isUndefined from '@roots/bud-support/isUndefined';
import logger from '@roots/bud-support/logger';
import set from '@roots/bud-support/set';
import DynamicOption from '@roots/bud-support/value';
/**
 * Bud extension
 */
export class Extension {
    /**
     * {@link Bud} instance get fn
     */
    _app;
    /**
     * Extension options
     *
     * @readonly
     */
    options;
    get app() {
        return this._app();
    }
    enabled = true;
    /**
     * ## Extension.meta
     *
     * @remarks
     * Tracks which extension methods have been executed to prevent
     * duplicate execution in race conditions, etc.
     */
    meta = {
        boot: false,
        buildAfter: false,
        buildBefore: false,
        compilerDone: false,
        configAfter: false,
        register: false,
    };
    /**
     * Class constructor
     */
    constructor(app) {
        this._app = () => app;
        this._options = this.options ? { ...this.options } : {};
        delete this.options;
        Object.defineProperty(this, `options`, {
            get: this.getOptions.bind(this),
        });
    }
    /**
     * Error handler
     */
    catch(error) {
        const label = this.label ?? this.constructor?.name ?? `unknown_extension`;
        if (error instanceof BudError) {
            throw error;
        }
        throw ExtensionError.normalize(error, {
            docs: new URL(`https://bud.js.org/docs/extensions`),
            issue: new URL(`https://github.com/roots/bud/search?q=is:issue+${label} in:title`),
            thrownBy: import.meta.url,
        });
    }
    /**
     * Disable extension
     * @deprecated pass `false` to {@link Extension.enable}
     */
    disable() {
        this.enabled = false;
    }
    /**
     * Return to bud instance from extension
     */
    done() {
        return this.app;
    }
    /**
     * Enable extension
     */
    enable(enabled = true) {
        this.logger.log(enabled ? `enabled` : `disabled`);
        if (enabled instanceof Bud) {
            this.enabled = true;
            return this;
        }
        this.enabled = enabled;
        return this;
    }
    /**
     * Get option
     */
    getOption(key) {
        return get(this.getOptions(), key);
    }
    /**
     * Get an option value
     */
    get = this.getOption;
    /**
     * Get options
     */
    getOptions() {
        return Object.entries(this._options).reduce((acc, [key, value]) => {
            if (isUndefined(value))
                return acc;
            if (!isObject(value))
                return { ...acc, [key]: value };
            const isDynamicOption = (value) => {
                return (value instanceof DynamicOption ||
                    (`isBudValue` in value && value.isBudValue));
            };
            const isDynamic = isDynamicOption(value);
            const unwrapped = isDynamic ? value.get()(this.app) : value;
            this.logger.info(key, `has value:`, isDynamic ? `${typeof unwrapped} (dynamic)` : typeof unwrapped);
            if (isUndefined(unwrapped))
                return acc;
            return { ...acc, [key]: unwrapped };
        }, {});
    }
    /**
     * Import ESM module
     */
    async import(signifier, context, options = {
        bustCache: false,
        raw: false,
    }) {
        return await this.app.module
            .import(signifier, context, options)
            .catch(this.catch);
    }
    /**
     * Is extension enabled?
     */
    isEnabled() {
        return `when` in this
            ? this.when(this.app, this.getOptions())
            : this.enabled;
    }
    /**
     * Logger instance
     */
    get logger() {
        const scopes = [];
        this.app.isChild && scopes.push(this.app.label);
        this.label && scopes.push(this.label);
        return logger.scope(...scopes);
    }
    /**
     * Resolve module using `import.meta.resolve` api
     */
    async resolve(signifier, context) {
        return await this.app.module.resolve(signifier, context);
    }
    /**
     * Set option
     */
    setOption(key, valueOrCallback) {
        if (isFunction(valueOrCallback)) {
            const resolved = valueOrCallback(this.get(key));
            set(this._options, key, resolved);
            this.logger.info(`set`, key, `=>`, resolved);
            return this;
        }
        set(this._options, key, valueOrCallback);
        this.logger.info(`set`, key, `=>`, valueOrCallback);
        return this;
    }
    /**
     * Set option
     */
    set = this.setOption;
    /**
     * Set options
     */
    setOptions(value) {
        this.logger.info(`set options`, value);
        this._options = value;
        return this;
    }
    async execute(key) {
        await this.app.resolvePromises();
        if (key === `make`) {
            if (!this.isEnabled())
                return false;
            if (!isUndefined(this.apply)) {
                this.logger.success(`produced hybrid compiler/bud plugin`);
                this.logger.info(this);
                return this;
            }
            if (!isUndefined(this.plugin)) {
                const plugin = new this.plugin({ ...this.getOptions() });
                this.logger.success(`produced compiler plugin`);
                this.logger.info(plugin);
                return plugin;
            }
            if (!isUndefined(this.make)) {
                const plugin = await this.make(this.app, { ...this.getOptions() });
                this.logger.success(`produced make plugin`);
                this.logger.info(plugin);
                return plugin;
            }
            return false;
        }
        if (isUndefined(this[key]))
            return;
        if (this.meta[key] === true)
            return;
        this.meta[key] = true;
        if ([`buildAfter`, `buildBefore`].includes(key) && !this.isEnabled())
            return;
        this.logger.log(`executing`, key);
        await this[key](this.app);
        await this.app.resolvePromises();
    }
}
__decorate([
    bind
], Extension.prototype, "catch", null);
__decorate([
    bind
], Extension.prototype, "disable", null);
__decorate([
    bind
], Extension.prototype, "done", null);
__decorate([
    bind
], Extension.prototype, "enable", null);
__decorate([
    bind
], Extension.prototype, "getOption", null);
__decorate([
    bind
], Extension.prototype, "getOptions", null);
__decorate([
    bind
], Extension.prototype, "import", null);
__decorate([
    bind
], Extension.prototype, "isEnabled", null);
__decorate([
    bind
], Extension.prototype, "resolve", null);
__decorate([
    bind
], Extension.prototype, "setOption", null);
__decorate([
    bind
], Extension.prototype, "setOptions", null);
__decorate([
    bind
], Extension.prototype, "execute", null);
export { DynamicOption };
