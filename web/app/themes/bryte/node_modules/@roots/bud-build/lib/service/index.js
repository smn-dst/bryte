import { __decorate } from "tslib";
import Item from '@roots/bud-build/item';
import Loader from '@roots/bud-build/loader';
import { register } from '@roots/bud-build/registry';
import Rule, {} from '@roots/bud-build/rule';
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators/bind';
import isFunction from '@roots/bud-support/isFunction';
import isUndefined from '@roots/bud-support/isUndefined';
/**
 * {@link BudBuild}
 */
class Build extends Service {
    /**
     * {@link BudBuild.config}
     */
    config = {};
    /**
     * {@link BudBuild.register}
     */
    register = register.bind(this);
    /**
     * {@link Service.register}
     */
    async bootstrap(app) {
        this.items = {};
        this.loaders = {};
        this.rules = {};
    }
    /**
     * {@link BudBuild.getItem}
     */
    getItem(name) {
        if (!this.items[name])
            this.logger.error(`loader ${name} was requested but is not registered`);
        return this.items[name];
    }
    /**
     * {@link BudBuild.getLoader}
     */
    getLoader(name) {
        if (!this.loaders[name])
            this.logger.error(`loader ${name} was requested but is not registered`);
        return this.loaders[name];
    }
    /**
     * {@link BudBuild.getRule}
     */
    getRule(ident) {
        return this.rules[ident];
    }
    /**
     * {@link BudBuild.make}
     */
    async make() {
        this.logger.log(`bud.build.make called`);
        await this.app.hooks.fire(`build.before`, this.app);
        await import(`@roots/bud-build/config`)
            .then(async (records) => await Promise.all(Object.entries(records).map(async ([prop, factory]) => {
            const value = await factory(this.app).catch(this.catch);
            if (isUndefined(value)) {
                this.logger.success(`omitting:`, prop, `(undefined)`);
                return;
            }
            Object.defineProperty(this.config, prop, {
                configurable: true,
                enumerable: true,
                value,
                writable: true,
            });
            this.logger
                .success(`defined:`, prop, `(${typeof this.config[prop]})`)
                .info(prop, `info:`, this.config[prop]);
        })))
            .catch(this.catch);
        this.logger.success(`configuration built`);
        this.logger.info(this.config);
        await this.app.hooks.fire(`build.after`, this.app).catch(this.catch);
        return Object.entries(this.config).reduce((a, [k, v]) => {
            if (isUndefined(v))
                return a;
            return { ...a, [k]: v };
        }, {});
    }
    /**
     * {@link BudBuild.makeItem}
     */
    makeItem(options) {
        return new Item(() => this.app, options);
    }
    /**
     * {@link BudBuild.makeLoader}
     */
    makeLoader(src, definition) {
        return new Loader(() => this.app, src, definition);
    }
    /**
     * {@link BudBuild.makeRule}
     */
    makeRule(options) {
        return new Rule(() => this.app, options);
    }
    /**
     * {@link BudBuild.setItem}
     */
    setItem(ident, definition) {
        this.logger.log(`build.setItem`, ident);
        const maybeOptionsCallback = isUndefined(definition)
            ? { ident, loader: ident }
            : definition;
        const item = isFunction(maybeOptionsCallback)
            ? maybeOptionsCallback(this.makeItem())
            : this.makeItem(maybeOptionsCallback);
        this.items[ident] = item;
        this.logger.info(item);
        return this;
    }
    /**
     * {@link BudBuild.setLoader}
     */
    setLoader(name, definition) {
        this.logger.log(`build.setLoader`, name);
        const loader = isUndefined(definition)
            ? this.makeLoader(name)
            : definition instanceof Loader
                ? definition
                : this.makeLoader(definition);
        this.loaders[name] = loader;
        this.logger.info(loader);
        return this;
    }
    /**
     * {@link BudBuild.setRule}
     */
    setRule(name, definition) {
        this.logger.log(`build.setRule`, name);
        const rule = definition instanceof Rule
            ? definition
            : isFunction(definition)
                ? definition(this.makeRule())
                : this.makeRule(definition);
        this.rules[name] = rule;
        this.logger.info(rule);
        return this;
    }
}
__decorate([
    bind
], Build.prototype, "bootstrap", null);
__decorate([
    bind
], Build.prototype, "getItem", null);
__decorate([
    bind
], Build.prototype, "getLoader", null);
__decorate([
    bind
], Build.prototype, "getRule", null);
__decorate([
    bind
], Build.prototype, "make", null);
__decorate([
    bind
], Build.prototype, "makeItem", null);
__decorate([
    bind
], Build.prototype, "makeLoader", null);
__decorate([
    bind
], Build.prototype, "makeRule", null);
__decorate([
    bind
], Build.prototype, "setItem", null);
__decorate([
    bind
], Build.prototype, "setLoader", null);
__decorate([
    bind
], Build.prototype, "setRule", null);
export { Build as default };
