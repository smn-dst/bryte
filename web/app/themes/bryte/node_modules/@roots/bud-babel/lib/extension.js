import { __decorate } from "tslib";
import { Extension } from '@roots/bud-framework/extension';
import { bind, expose, label, } from '@roots/bud-framework/extension/decorators';
import { InputError } from '@roots/bud-support/errors';
import isString from '@roots/bud-support/isString';
import isUndefined from '@roots/bud-support/isUndefined';
/**
 * Babel configuration
 */
let BabelExtension = class BabelExtension extends Extension {
    /**
     * Babel env
     */
    env = {
        development: { compact: false },
    };
    /**
     * Plugins registry
     */
    plugins = {};
    /**
     * Presets registry
     */
    presets = {};
    /**
     * Cache directory
     */
    get cacheDirectory() {
        return this.app.cache.enabled && this.app.cache.cacheDirectory
            ? this.app.path(this.app.cache.cacheDirectory, `babel`)
            : false;
    }
    /**
     * Config file accessor
     */
    get configFile() {
        return Object.values(this.app.context.files).find(file => file.name.includes(`babelrc`) || file.name === `babel.config`);
    }
    /**
     * Get babel env value
     */
    getEnv() {
        return this.env;
    }
    /**
     * Loader options
     *
     * @readonly
     */
    get loaderOptions() {
        const baseOptions = {
            cacheDirectory: this.cacheDirectory,
            cacheIdentifier: `babel`,
        };
        if (this.configFile) {
            return { ...baseOptions, ...this.configFileOptions };
        }
        return {
            ...baseOptions,
            configFile: false,
            env: this.env,
            plugins: Object.values(this.plugins),
            presets: Object.values(this.presets),
            root: this.root,
            targets: this.app.context.manifest?.browserslist ?? {
                esmodules: true,
            },
        };
    }
    /**
     * {@link Extension.register}
     */
    async register({ build, hooks }) {
        const loader = await this.resolve(`babel-loader`, import.meta.url);
        if (!loader)
            throw new Error(`babel-loader not found`);
        hooks.on(`build.resolveLoader.alias`, (alias = {}) => ({
            ...alias,
            [`babel-loader`]: loader,
        }));
        if (this.configFile) {
            this.logger.log(`Babel configuration is being overridden by project configuration file.`);
            this.configFileOptions =
                this.configFile.module?.default ?? this.configFile.module;
            hooks.on(`build.cache.buildDependencies`, (paths = {}) => {
                if (isString(this.configFile)) {
                    paths.babel = [this.configFile];
                    this.logger.success(`babel config added to webpack build dependencies`);
                }
                return paths;
            });
            return;
        }
        const presetEnv = await this.resolve(`@babel/preset-env`, import.meta.url);
        if (presetEnv)
            this.setPreset(`@babel/preset-env`, presetEnv);
        const transformRuntime = await this.resolve(`@babel/plugin-transform-runtime`, import.meta.url);
        if (transformRuntime)
            this.setPlugin(`@babel/plugin-transform-runtime`, [
                transformRuntime,
                { helpers: false },
            ]);
        build.setLoader(`babel`, `babel-loader`).setItem(`babel`, {
            loader: `babel`,
            options: () => this.loaderOptions,
        });
        build.rules.js.setUse((items = []) => [`babel`, ...items]);
    }
    /**
     * Root directory
     */
    get root() {
        return this.app.path();
    }
    /**
     * Set babel env value
     *
     * @param env - Babel env
     * @returns this
     */
    setEnv(env) {
        this.env = env;
        return this;
    }
    /**
     * Set a babel plugin
     */
    setPlugin(name, plugin) {
        if (!plugin) {
            this.plugins[name[0]] = Array.isArray(name) ? name : [name];
            return this;
        }
        if (Array.isArray(name)) {
            throw new InputError(`Invalid plugin name`);
        }
        this.plugins[name] = Array.isArray(plugin) ? plugin : [plugin];
        return this;
    }
    /**
     * Set options on a babel plugin
     */
    setPluginOptions(plugin, options) {
        this.plugins[plugin] = [this.plugins[plugin].shift(), options];
        return this;
    }
    /**
     * Set babel plugins
     */
    setPlugins(plugins) {
        this.plugins = Object.entries(plugins).reduce((plugins, [name, plugin]) => ({
            ...plugins,
            [name]: Array.isArray(plugin) ? plugin : [plugin],
        }), {});
        return this;
    }
    /**
     * Set a babel preset
     */
    setPreset(name, preset) {
        if (!preset) {
            this.presets[name[0]] = Array.isArray(name) ? name : [name];
            return this;
        }
        if (Array.isArray(name)) {
            throw new InputError(`Invalid preset name`);
        }
        this.presets[name] = Array.isArray(preset) ? preset : [preset];
        return this;
    }
    /**
     * Set options on a babel preset
     */
    setPresetOptions(preset, options) {
        this.presets[preset] = [this.presets[preset].shift(), options];
        return this;
    }
    /**
     * Set babel presets
     */
    setPresets(presets) {
        this.presets = Object.entries(presets).reduce((presets, [name, preset]) => ({
            ...presets,
            [name]: Array.isArray(preset) ? preset : [preset],
        }), {});
        return this;
    }
    /**
     * Remove a babel plugin
     */
    unsetPlugin(plugin) {
        if (!isUndefined(this.plugins[plugin]))
            delete this.plugins[plugin];
        return this;
    }
    /**
     * Remove a babel preset
     */
    unsetPreset(preset) {
        if (!isUndefined(this.presets[preset]))
            delete this.presets[preset];
        return this;
    }
};
__decorate([
    bind
], BabelExtension.prototype, "register", null);
__decorate([
    bind
], BabelExtension.prototype, "setPlugin", null);
__decorate([
    bind
], BabelExtension.prototype, "setPluginOptions", null);
__decorate([
    bind
], BabelExtension.prototype, "setPlugins", null);
__decorate([
    bind
], BabelExtension.prototype, "setPreset", null);
__decorate([
    bind
], BabelExtension.prototype, "setPresetOptions", null);
__decorate([
    bind
], BabelExtension.prototype, "setPresets", null);
__decorate([
    bind
], BabelExtension.prototype, "unsetPlugin", null);
__decorate([
    bind
], BabelExtension.prototype, "unsetPreset", null);
BabelExtension = __decorate([
    label(`@roots/bud-babel`),
    expose(`babel`)
], BabelExtension);
export { BabelExtension as default };
