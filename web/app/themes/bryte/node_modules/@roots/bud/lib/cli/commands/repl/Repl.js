import { jsx as _jsx, jsxs as _jsxs } from "@roots/bud-support/jsx-runtime";
import chunk from '@roots/bud-support/chunk';
import { BudError } from '@roots/bud-support/errors';
import { highlight } from '@roots/bud-support/highlight';
import { Box, Text, TextInput, useEffect, useInput, useState, } from '@roots/bud-support/ink';
import format from '@roots/bud-support/pretty-format';
export const Repl = ({ app, depth, indent }) => {
    const [search, setSearch] = useState(``);
    const [result, setResult] = useState(``);
    const [paged, setPaged] = useState([]);
    const [page, setPage] = useState(0);
    const [action, setAction] = useState(``);
    const pageSize = Math.max(process.stdout.rows - 7, 10);
    useInput((input, key) => {
        if (key.escape) {
            // eslint-disable-next-line
            process.exit(0);
        }
        if (key.upArrow) {
            setAction(`up`);
            page >= 1 ? setPage(page - 1) : setPage(paged.length - 1);
        }
        if (key.downArrow) {
            setAction(`down`);
            page < paged.length - 1 ? setPage(page + 1) : setPage(0);
        }
        if (key.tab) {
            setAction(`tab`);
            setSearch(``);
        }
        if (key.return) {
            setAction(`return`);
            setResult(``);
            setPaged([]);
            setPage(0);
        }
        if (!key.return &&
            !key.tab &&
            !key.downArrow &&
            !key.upArrow &&
            !key.escape) {
            setAction(`alpha`);
        }
    });
    useEffect(() => {
        action !== `` &&
            setTimeout(() => {
                setAction(``);
            }, 500);
    }, [action]);
    useEffect(() => {
        if (result) {
            const page = chunk(result.split(`\n`), pageSize).map(page => page.join(`\n`));
            setPaged(page);
        }
    }, [result, pageSize]);
    useEffect(() => {
        if (page > paged.length) {
            setPage(Math.max(paged.length - 1, 0));
        }
    }, [page, paged]);
    const makeFn = (value) => eval(`async (bud) => ${value};`);
    const processResults = (raw) => {
        if (raw === undefined) {
            setResult(`undefined`);
            return;
        }
        try {
            const result = highlight(format(raw, {
                indent: parseInt(indent),
                maxDepth: parseInt(depth),
            }));
            setResult(result);
        }
        catch (error) {
            setResult(BudError.normalize(error).message);
        }
    };
    const onSubmit = (value) => {
        ;
        (async () => {
            try {
                const fn = makeFn(value);
                const results = await fn(app);
                await app.build.make();
                if (app.hasChildren)
                    await Promise.all(Object.entries(app.children).map(async ([_, child]) => await child.build.make()));
                processResults(results);
            }
            catch (error) {
                setResult(BudError.normalize(error).message);
            }
        })();
    };
    return (_jsxs(Box, { flexDirection: "column", children: [_jsxs(Box, { flexDirection: "column", marginY: 1, children: [_jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [_jsx(Box, { borderBottom: false, borderLeft: true, borderLeftColor: action === `alpha` ? `green` : `dim`, borderRight: false, borderStyle: "single", borderTop: false, flexDirection: "row", justifyContent: "flex-start", marginBottom: paged.length ? 1 : 0, paddingLeft: 1, children: _jsx(TextInput, { onChange: setSearch, onSubmit: onSubmit, placeholder: "bud.build.config.entry", showCursor: true, value: search }) }), paged.length > 0 ? (_jsxs(Box, { flexDirection: "row", justifyContent: "flex-start", marginTop: 1, children: [_jsxs(Text, { color: action === `up` || action === `down` ? `green` : `white`, children: ["page", ` `] }), _jsx(Text, { color: action === `up` || action === `down` ? `green` : `white`, children: page + 1 }), _jsx(Text, { children: "/" }), _jsx(Text, { color: action === `up` || action === `down` ? `green` : `white`, children: paged.length })] })) : null] }), paged[page] ? (_jsx(Box, { borderBottom: false, borderLeft: true, borderLeftColor: "dim", borderRight: false, borderStyle: "single", borderTop: false, flexDirection: "column", justifyContent: "flex-start", paddingLeft: 1, children: _jsx(Text, { children: paged[page] }) })) : null] }), _jsxs(Box, { flexDirection: "row", marginY: 1, children: [_jsxs(Text, { children: [_jsx(Text, { backgroundColor: action === `esc` ? `green` : `white`, color: "black", children: "[esc]" }), ` `, "quit"] }), _jsx(Text, { children: `  ` }), _jsxs(Text, { children: [_jsx(Text, { backgroundColor: action === `tab` ? `green` : `white`, color: "black", children: "[tab]" }), ` `, "clear"] }), _jsx(Text, { children: `  ` }), _jsxs(Text, { children: [_jsx(Text, { backgroundColor: action === `down` ? `green` : `white`, color: "black", children: "[\u2193]" }), ` `, "next"] }), _jsx(Text, { children: `  ` }), _jsxs(Text, { children: [_jsx(Text, { backgroundColor: action === `up` ? `green` : `white`, color: "black", children: "[\u2191]" }), ` `, "prev"] }), _jsx(Text, { children: `  ` }), _jsxs(Text, { children: [_jsx(Text, { backgroundColor: action === `return` ? `green` : `white`, color: "black", children: "[return]" }), ` `, "eval"] })] })] }));
};
